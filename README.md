# java-projects

A structured collection of Java console applications developed through object-oriented design principles. The projects demonstrate core software engineering concepts—control flow, abstraction, encapsulation, arrays, and method composition—applied to practical simulations such as payroll computation, geometric modeling, ASCII-based graphics, and interactive decision games.

---

## **Project Included**
### Stat Analysis
**Code:** [Stat.java](Stat.java)  

This program performs key statistical computations:mean, median, mode, minimum, and maximum on numerical datasets.  
It demonstrates algorithmic thinking, array manipulation, iterative logic, and method decomposition. The project highlights how structured program flow can be used to transform raw data into meaningful insights.

### Drawing Shapes
**Code:** [DrawingShapes.java](DrawingShapes.java)

This program generates ASCII-based geometric patterns such as rectangles, triangles, hexagons, octagons, and pentagons based on user input. By combining nested loops, conditionals, and user input, it demonstrates algorithmic control flow and creative problem-solving. The project highlights the connection between logic, iteration, and visual design in console-based programming.

### Rock Paper Scissors
**Code:** [RockPaperScissors.java](RockPaperScissors.java) | [ComputerOpponent.java](ComputerOpponent.java)

This interactive game simulates the classic Rock–Paper–Scissors match between the user and a computer opponent.  
The program’s modular design separates user interaction and computer logic into two files:  
`RockPaperScissors.java` manages input, scoring, and round progression, while `ComputerOpponent.java` controls the computer’s randomized or test-driven move generation. Together, they demonstrate principles of modular design, randomization, and decision-making algorithms in a user-interactive console program.

### String Fun
**Code:** [StringFun.java](StringFun.java)
This program offers an interactive toolkit for string manipulation, supporting reverse, replace-first, replace-last, remove-all, and remove-kth operations. It emphasizes precise control over text through iterative algorithms, character-level indexing, and robust input handling (e.g., graceful messages for “not found,” empty input, or invalid k). The design factors functionality into small helper methods—such as first/last index search, k-th occurrence removal, and safe parsing—to keep logic modular, testable, and easy to extend.
